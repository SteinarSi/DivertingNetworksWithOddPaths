\section{Psuedocode}

\subsection{Initialization and the main control loop}
\begin{lstlisting}[caption={Main},label=Listing,mathescape=true]
fn main(input_graph, s, t){
    init(input_graph, s, t);

    while ! control() {}

    if d_minus[t] == $\infty$ {
        // The graph is a no-instance, no odd s-t-paths exist
        return None;
    }

    current_edge = pred[t];
    path = [current_edge];
    while from(current_edge) != s {
        current_edge = pred[mirror(from(current_edge))];
        if from(current_edge) < input_graph.n() {
            path.push(current_edge);
        }
        else {
            path.push(shift_edge_by(current_edge, -input_graph.n()));
        }
    }
    return Some(d_minus[t], path);
}
\end{lstlisting}

\begin{lstlisting}[caption={Initialization},label=Listing,mathescape=true]
fn init(input_graph, s, t) {
    graph = create_mirror_graph(input_graph);

    for u in 0..n {
        d_plus[u] = $\infty$;
        d_minus[u] = $\infty$;
        pred[u] = null;
        completed[u] = false;
        basis[u] = u;
    }
    d_plus[s] = 0;
    completed[s] = true;

    for edge in graph[s] {
        pq.push(Vertex(weight(edge), to(edge)));
        d_minus[to(edge)] = weight(edge);
        pred[to(edge)] = e;
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Control, the main loop},label=Listing,mathescape=true]
fn control() -> bool {
    while ! pq.is_empty() {
        match pq.top() {
            Vertex(_, u) => {
                if completed[u] {
                    pq.pop();
                }
                else {
                    break;
                }
            },
            Blossom(_, edge) => {
                if base_of(from(edge)) == base_of(to(edge)) {
                    pq.pop();
                }
                else {
                    break;
                }
            }
        }
    }

    if pq.is_empty() {
        // No odd s-t-paths in G exist :(
        return true;
    }
    match pq.pop() {
        Vertex(delta, l) => {
            if l == t {
                // We have found a shortest odd s-t-path has been found :)
                return true;
            }
            grow(l);
        }
        Blossom(delta, edge) => {
            blossom(e);
        }
    }
    return false;
}
\end{lstlisting}

\subsection{Scanning vertices}
\begin{lstlisting}[caption={Grow},label=Listing,mathescape=true]
fn grow(l) {
    d_plus[mirror(l)] = d_minus[l];
    scan(mirror(l));
}
\end{lstlisting}

\begin{lstlisting}[caption={Scan},label=Listing,mathescape=true]
fn scan(u) {
    completed[u] = true;
    dist_u = d_plus[u];
    for edge in graph[u] {
        v = to(edge);
        new_dist_v = dist_u + weight(edge);

        if ! completed[v] {
            if new_dist_v < d_minus[v] {
                d_minus[v] = new_dist_v;
                pred[v] = edge;
                pq.push(Vertex(new_dist_v, v));
            }
        }
        else if d_plus[v] < $\infty$ and base_of(u) != base_of(v) {
            pq.push(Blossom(d_plus[u] + d_plus[v] + weight(edge)));
            if new_dist_v < d_minus[v] {
                d_minus[v] = new_dist_v;
                pred[v] = e;
            }
        }
    }
}

\end{lstlisting}

\subsection{Computing blossoms}
\begin{lstlisting}[caption={Blossom},label=Listing,mathescape=true]
fn blossom(edge) {
    (b, p1, p2) = backtrack_blossom(edge);

    List<int> to_scan1 = set_blossom_values(p1);
    List<int> to_scan2 = set_blossom_values(p2);

    set_edge_bases(b, p1);
    set_edge_bases(b, p2);

    for u in to_scan1 {
        scan(u);
    }
    for v in to_scan2 {
        scan(v);
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Backtrack blossom},label=Listing,mathescape=true]
fn backtrack_blossom(edge) {
    // TODO
}
\end{lstlisting}


\begin{lstlisting}[caption={Set blossom values},label=Listing,mathescape=true]
fn set_blossom_values(path) {
    to_scan = [];

    for edge in path {
        u = from(edge);
        v = to(edge);
        w = weight(edge);
        in_current_cycle[u] = false;
        in_current_cycle[v] = false;

        // We can set a d_minus
        if d_plus[v] + w < d_minus[u] {
            d_minus[u] = d_plus[v] + w;
            pred[u] = reverse(edge);
        }

        int m = mirror(u);
        // We can set a d_plus, and scan it
        if d_minus[u] < d_plus[m] {
            d_plus[m] = d_minus[u];
            to_scan.push(m);
        }
    }

    return to_scan;
}
\end{lstlisting}

\begin{lstlisting}[caption={Set edge bases},label=Listing,mathescape=true]
    fn set_edge_bases(path) {
        for edge in path {
            u = from(edge);
            m = mirror(edge);
            set_base(u, b);
            set_base(m, b);
        }
    }
    \end{lstlisting}

\subsection{Setting the base of blossoms and psuedonodes}
When we have found and computed a blossom, we shrink it into a psuedonode by setting the base of all its vertices to the base of the blossom. Whenever we consider a potential blossom edge, we see if the two vertices have the same base, and if they do, they are in fact already in the same psuedonode and the edge can be disregarded. Whenever we set $u$ to have the base $b$, we also have to see if any other vertices have $u$ as their base and set their bases to $b$ as well. Derigs never specified any data structure to update these bases efficiently.

The naïve solution would be to do something like this:
\begin{lstlisting}[caption={Näive basis},label=Listing,mathescape=true]
fn set_base(b, u) {
    basis[u] = b;
    for v in 0..n {
        if basis[v] == u {
            basis[v] = b;
        }
    }
}
fn get_base(u) {
    return basis[u];
}
\end{lstlisting}
This would search through all vertices in the graph in linear time. We have found two potential improvements to this. The first version is to use an oberserver pattern, where each vertex $u$ keeps a record of the vertices that have $u$ as its base. Initially $dependents[u] = []$ for all of them. Then, when we update $u$'s base to $b$:

\begin{lstlisting}[caption={Observer basis},label=Listing,mathescape=true]
fn set_base(b, u) {
    basis[u] = b;
    dependents[b].push(u);
    for v in dependents[u] {
        basis[v] = b;
        dependents[b].push(v);
    }
}
\end{lstlisting}

Now we only go through the vertices that have $u$ as their base, in time linear to the count of vertices that need to be updated.

The second version is to use a structure resembling union-find, where each disjoint set and its representative is a blossom and its base. To update the base of $u$ we simply set the new base and do nothing else. When we require the base of a vertex we recursively query its representative's base and contract the path along the way in the style of union-find. 

\begin{lstlisting}[caption={UF-like basis},label=Listing,mathescape=true]
fn set_base(b, u) {
    basis[u] = b;
}
fn get_base(u) -> int {
    if u != basis[u] {
        basis[u] = get_base(basis[u]);
    }
    return basis[u];
}

\end{lstlisting}

Now we can update a base in constant time, with the tradeoff of potentially slower queries.

TODO gjør eksperimenter.

\section{Notes on implementing the psuedocode}