\section{Improvements on Derigs' algorithm}
The main idea of our algorithm is the same as the original by Derigs \cite{derigs_shortest_odd_path}. We have, however, made some improving adjustments, and we will discuss these here.

First of all, the original algorithm used the idea of building up an tree $T$ of alternating edges to mark scanned vertices as done. This is to avoid scanning the same vertex multiple times, and to make sure that a blossom edge is only put into the queue after both its vertices have been scanned. The notation $V(T) := V(T) \cup \{k,l\}$ was used to mark $k$ as done. The problem we had with this was that only mirror edges were ever added to the tree, so the tree wouldn't be connected, and the notation was confusing and overly complex for such a simple concept. We have replaced this with a boolean array called \pyth{completed}, where each vertex $u$ initially has \pyth{completed[u] = false} until it has been scanned, at which point we set \pyth{completed[u] = true}. It does the job.

Secondly, we have chosen to utilize sum types to have one priority queue with both vertices and blossom edges in one. The old algorithm used two priority queues that it always had to query together, which was difficult to read and debug. We find that combining them into one queue simplifies the code greatly. The way we compare their priorities is also different: vertices have a priority of \emph{twice} its $d^-$, so that blossom edges can have a priority of the sum of its two $d^+$'s and its edge weight without dividing by two. Again do we find this simpler, and we no longer have to convert integer weights to floating points just to prioritize them correctly.

Thirdly, union-find. TODO.

TODO: tree vs completed, sum types, easier comparison and better queue priority to avoid floats, union-find, 