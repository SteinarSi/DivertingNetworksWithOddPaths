\section{Improvements on Derigs' algorithm}
The main idea of our algorithm is the same as the original by Derigs \cite{source:derigs_shortest_odd_path}. We have, however, made some improving adjustments, and we will discuss these here.

First, the original algorithm used the idea of building up a tree $T$ of alternating edges to mark scanned vertices as done. This is to avoid scanning the same vertex multiple times and to make sure that a blossom edge is only put into the queue after both its vertices have been scanned. The notation $V(T) := V(T) \cup \{k,l\}$ was used to mark $k$ as done. We had multiple problems with this. To begin, only the matched edges are ever added to the tree, so the disconnected 'tree' would not be a tree at all. Furthermore, unlike how for example Dijkstra's Algorithm builds up an implicit tree of scanned vertices, the vertices in our mirror graph are not at all scanned in the order of distance to the source, so even if we added actual edges to the tree it would still not be a tree. Finally, we found that the notation was misleading and overly complex for what really should be a simple concept. We have replaced this with a boolean array called \pyth{completed}, where each vertex $u$ initially has \pyth{completed[u] = false} until it has been scanned, at which point we set \pyth{completed[u] = true}. It does the job.

Second, we have chosen to utilize sum types to have one priority queue with both vertices and blossom edges in one. The original algorithm used two priority queues that it always had to query together, which was difficult to read, write, and debug. We find that combining them into one queue simplifies the code greatly. The way we set their priorities is also different: vertices now have a priority of \emph{twice} its $d^-$, so that blossom edges can have a priority of the sum of the $d^+$'s of its two endpoints and its edge weight \emph{without} dividing by two afterwards. Again do we find this simpler, and we no longer have to convert integer weights to floating points just to prioritize them correctly.

Third, we developed a new data structure to store and update the basis of each vertex. See \Cref{subsection:basis-code} for a discussion of different structures, and \Cref{subsubsection:testing-basis} for an empirical analysis of the improvement.
 
Fourth, and this is more subjective, we will argue that we have improved the presentation of the algorithm. Derigs' algorithm is both very neat and very useful, but we believe that the way it is presented in the original paper \cite{source:derigs_shortest_odd_path} is too terse in many places, and overly complex in others. We speak from experience when we say that implementing the algorithm was a challenge where we had to figure out many details ourselves. One of our goals with this thesis is to give a better starting point for programmers who wish to implement the algorithm themselves, to make this neat algorithm more accessible.
\todo{Er dette ydmykt nok?}