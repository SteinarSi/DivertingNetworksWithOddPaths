\section{Improvements on Derigs' algorithm}
The main idea of our algorithm is the same as the original by Derigs \cite{source:derigs_shortest_odd_path}. We have, however, made some improving adjustments, and we will discuss these here.

First of all, the original algorithm used the idea of building up a tree $T$ of alternating edges to mark scanned vertices as done. This is to avoid scanning the same vertex multiple times, and to make sure that a blossom edge is only put into the queue after both its vertices have been scanned. The notation $V(T) := V(T) \cup \{k,l\}$ was used to mark $k$ as done. We had multiple problems with this. Firstly, only mirror edges are ever added to the tree, so the disconnected 'tree' would not be a tree at all. Secondly, unlike how for example Dijkstra's Algorithm builds up an implicit tree of scanned vertices, the vertices in our mirror graph are not at all scanned in the order of distance to the source, so even if we added actual edges to the tree it would not be a tree. Lastly, we found that the notation was misleading and overly complex for what really should be a simple concept. We have replaced this with a boolean array called \pyth{completed}, where each vertex $u$ initially has \pyth{completed[u] = false} until it has been scanned, at which point we set \pyth{completed[u] = true}. It does the job.

Secondly, we have chosen to utilize sum types to have one priority queue with both vertices and blossom edges in one. The old algorithm used two priority queues that it always had to query together, which was difficult to read and debug. We find that combining them into one queue simplifies the code greatly. The way we compare their priorities is also different: vertices have a priority of \emph{twice} its $d^-$, so that blossom edges can have a priority of the sum of the $d^+$'s of its two endpoints and its edge weight \emph{without} dividing by two afterwards. Again do we find this simpler, and we no longer have to convert integer weights to floating points just to prioritize them correctly.

Thirdly, we came up with a new data structure to keep and update the basis of each vertex. See Section \ref{subsection:basis-code} for a discussion of different structures, and Subsection \ref{subsubsection:testing-basis} for an empirical analysis of the improvement.
