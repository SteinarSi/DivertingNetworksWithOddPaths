Before we start on the main topic of this thesis, we want to discuss a closely related problem:

\noindent\fbox{\parbox{0.94\textwidth}{\textsc{Shortest Odd Walk}\\
    \textbf{Input:} A weighted graph $G$, two vertices $s,t \in V$\\
    \textbf{Output:} the shortest $s$-$t$-walk in $G$ that uses an odd number of edges
}}

The difference is simple: a walk may use the same vertices multiple times, whereas a path can not. A na√Øve attempt at solving \textsc{Shortest Odd Path} will often accidentally use the same vertices multiple times, and then be an odd walk instead. Therefore, we want to present an algorithm to solve \textsc{Shortest Odd Walk} first, and explain why it does not solve \textsc{Shortest Odd Path}.

\section{Intuition}
Our algorithm will take inspiration from Dijkstra's algorithm for \textsc{Shortest Path}, and assume that all the edges have non-negative weights. Remember, in Dijkstra's algorithm we have an array to keep the tentative best distance to each vertex. In this algorithm, we will keep two such arrays, one for the best distance using an odd walk, and one for the best distance using an even walk. Each vertex can be scanned at most twice: once when we have found the definitive best odd walk and want to find potential improvements to the even walks of its neighbours, and similar when we find the best odd walk.

