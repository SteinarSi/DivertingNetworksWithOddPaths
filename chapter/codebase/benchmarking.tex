\section{Benchmarking}
\label{section:benchmarking}
To benchmark our algorithms for \textsc{Shortest Odd Walk} and \textsc{Shortest Odd Path}, we have picked seven different graphs from real-life scenarios of various sizes. We focus on sparse graphs, where the number of edges is not too large compared to the vertices. All benchmarks are run on a laptop with 16GB of memory and an i5-1155G7 of 2.5 to 4.5GHz, which we will denote as an \emph{average laptop}. During the runs, we make sure that the power cable is plugged in and that other processes are shut down, for maximum performance.

To compare the theoretical and practical runtimes of our algorithms, we need a collection of graphs of easily scalable sizes. Furthermore, as to also be used for benching \textsc{Network Diversion}, the graphs have to be planar graphs with a built-in planar embedding.

Our solution is this: for a given integer $n$, generate $n$ random points in the plane, to be the vertices in our graph. Then, using the \pyth{scipy} library in Python, compute a Delaunay triangulation of the points. Each of the triangles in the triangulation consists of three points, inbetween of which we add three edges with random weights. Extra care must be taken not to add the same edge multiple times, once for each of the two triangles it is adjacent to. The result is a straight-line embedding of a planar graph of size $n$, where each face is a triangle in the triangulation, and the dual graph is a Voronoi diagram of the set of points. Though the term is not common, we like to refer to a graph generated like this as a \emph{Delaunay graph}. Now we have a technique to generate straight-line embeddings of graphs of arbitrary size, which is exactly what we need for benchmarking. Another advantage is that these graphs often look quite aesthetically pleasing, as seen in \Cref{figure:network-diversion-on-delaunay}.

Using this technique, we generate 200 Delaunay graphs of sizes 1000, 2000, 3000, and so on until 200k. Then we use a few heuristic searches to estimate pairs of vertices that are the farthest away from each other, as inputs for our \textsc{Shortest Odd Walk} and \textsc{Shortest Odd Path} algorithms. After that, we select some of the worst diversion edges farthest away from these pairs, as inputs for our \textsc{Network Diversion}. The intention is that each graph gets queries that are the worst or close to the worst possible case so that the size of the problem roughly matches the size of the graph.

The interested reader may visit the GitHub repository \cite{source:codebase} to see the graphs and the Python scripts used to generate them.
