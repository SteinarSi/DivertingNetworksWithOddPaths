\section{Algorithms}
We have successfully implemented the following algorithms:

\begin{itemize}
    \item \textsc{Shortest Odd Walk} on graphs of non-negative weights, as described in \Cref{chapter:odd-walk}.
    \item \textsc{Shortest Odd Path} on undirected graphs of non-negative weights, as described in \Cref{chapter:odd-path}.
    \item \textsc{Network Diversion} on undirected planar graphs of non-negative weights, as described in \Cref{chapter:network-diversion}.
    \item \textsc{Shortest Path} on unweighted graphs, using a classic breadth-first search.
    \item \textsc{Shortest Path} on graphs of non-negative weights, using Dijkstra's Algorithm as shown in \Cref{algorithm:dijkstras-algorithm}.
    \item \textsc{Shortest Bottleneck Path} on undirected graphs of non-negative weights, as described in \Cref{section:subdividing-bottlenecks}.
\end{itemize}

With the obvious exception of the breadth-first search are all of them generic with respect to edge weights, and can handle any type of weights like \pyth{i32}, \pyth{u64} and \pyth{f64}. When we subdivide edges in \textsc{Network Diversion} and \textsc{Shortest Bottleneck Path} we use a neat little trick to be able to split a weight into two weights without potentially accidentally rounding down an integer: we set one weight to zero and the other to the original weight. Any path that uses one of those edges will have to use the other afterwards, and their sum will then be the same as the original weight prior to the split.

\todo[inline]{write about the algorithms}